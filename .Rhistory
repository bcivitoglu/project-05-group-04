df[df == 0] <- NA
###2 Go through each row and sum up the NAÂ´s
rmv.rows = apply(df,1, function(x){sum(is.na(x))})
###3 Number of NA`s greater i
which(rmv.rows > i)
### Or even i
which (rmv.rows == i)
###4 Remove your old Dataset with the NAÂ´s with your new Dataset without the NAÂ´s (Remove any row with more than i NAÂ´s)
df = df[-which(rmv.rows > i),]
## Coverage Values
###1 Show me all the Values within the 90% quantile
df[df$specialcolumn < quantile(df$specialcolumn, 0.90),]
###2 Create new dataset with just the values inside 90% quantile
df_new = df[df$specialcolumn < quantile(df$specialcolumn, 0.90),]
# Trying to remove special coverage values (Question at the end)
##1 Create new dataframe only with coverage values (genes)
coverage <- genes[,c(21:30)]
##2 Only keep values within the 90% quantile
coverage_cleaned = coverage[coverage$Bcell_mem_VB_C003JB51.bed_coverage < quantile(coverage$Bcell_mem_VB_C003JB51.bed_coverage, 0.90),]
##3 Compare range of columns
###Column of first healthy patient
range(coverage$Bcell_mem_VB_C003JB51.bed_coverage)
[1]       0 1552321
range(coverage_cleaned$Bcell_mem_VB_C003JB51.bed_coverage)
[1]     0 38338
###Column of first cancer patient
range(coverage$cancer_VB_S00AYXU1.bed_coverage)
[1]      0 652507
range(coverage_cleaned$cancer_VB_S00AYXU1.bed_coverage)
[1]      0 236806
Example-note: Do not remove the quantiles in this way for more than one column
Tim versucht nochmal was zu Ã¤ndern
file:///C:/Users/Leona/Documents/Uni/4. Semester/CLL-Bcell Projekt/sample_annotation.csv
file:///C:/Users/Leona/Documents/Uni/4. Semester/CLL-Bcell Projekt/sample_annotation.csv
ï»¿---
title: "DNA Methylation"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## R Markdown
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
```{r cars}
summary(cars)
```
## Including Plots
You can also embed plots, for example:
```{r pressure, echo=FALSE}
plot(pressure)
```
Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
#Start the project
##Legend
df = data frame
## To make sure which file on my computer offers the environment for my R project:
getwd()
#Read in the data
input_data <- readRDS(file ="CLL-Bcells_list.RDS.gz")
annotation <- read.csv("sample_annotation.csv")
##Divide the data in 3 subgroups
genes <- input_data$genes
promoters <- input_data$promoters
cpgislands <- input_data$cpgislands
# Rename a column
## If you know the number of the columns
names(df)[number_of_col] <- "new_name"
E.g: names(genes)[1] <- "new_name"
##If you have too many columns to know the number
colnames(df)[colnames(df)=="old_name"] <- "new_name"
E.g: colnames(genes)[colnames(genes)=="old_name"] <- "new_name"
#Show if columns have missing values
sum(is.na(df))
--> Number of missing values is shown as result
# Set NAÂ´s to a defined number
df[is.na(df)] <- set_number
E.g.: genes$Symbol[is.na(genes$Symbol)] <- 0
# Set 0 to NA
df[df == 0] <- NA
E.g.: genes$Symbol[genes$Symbol == 0] <- NA
# Create new data frames with selected columns
## Create a data frame with selected columns using indices
dfnew1 <- genes[,c(1,2,3,4,5)]
## Create a data frame with selected columns using indices (easier)
dfnew2 <- genes [, c(1:5)]
## Create a data frame using the names of the columns
dfnew1 <- data.frame(df$subpoint1, df$subpoint2)
E.g.: dfnew1 <- data.frame(genes$Chromosome, genes$CpG)
### Rename all the (old) columns at once ("Chromosome" --> "Chr" ; "CpG" --> "CpGÂ´s")
names(dfnew1) <- c("Chr", "CpG Â´s")
#Visualization
## Histogram (for CpG derivation)
hist(df, main = "Headline", xlab = "Name of x-axis", xlim = c(Starting_Number, Ending_Number), breaks = How_Many_Intervalls)
hist(cpgislands$CpG, main = "Histogram for CpG derivation", xlab = "Number of CpGÂ´s in Region", xlim = c(0,600), breaks = 200)
## Density plot (for CpG derivation)
plot(df), xlab = "X-axis name", main = "",xlim = c(Starting_Number, Ending_Number))
plot(density(genes$CpG), xlab = "Number of CpGÂ´s", main = "",xlim = c(0,2000))
## Boxplots (+modify)
boxplot(df1,df2)
boxplot(df1,df2, xlab = "Example_1", horizontal = T, ylim = c(0,1), ylab = "Non-cancer vs. CLL")
#Clean up our data
## Beta Values
###1 Set all Zero to NAÂ´s (due to possible mistakes)
df[df == 0] <- NA
###2 Go through each row and sum up the NAÂ´s
rmv.rows = apply(df,1, function(x){sum(is.na(x))})
###3 Number of NA`s greater i
which(rmv.rows > i)
### Or even i
which (rmv.rows == i)
###4 Remove your old Dataset with the NAÂ´s with your new Dataset without the NAÂ´s (Remove any row with more than i NAÂ´s)
df = df[-which(rmv.rows > i),]
## Coverage Values
###1 Show me all the Values within the 90% quantile
df[df$specialcolumn < quantile(df$specialcolumn, 0.90),]
###2 Create new dataset with just the values inside 90% quantile
df_new = df[df$specialcolumn < quantile(df$specialcolumn, 0.90),]
# Trying to remove special coverage values (Question at the end)
##1 Create new dataframe only with coverage values (genes)
coverage <- genes[,c(21:30)]
##2 Only keep values within the 90% quantile
coverage_cleaned = coverage[coverage$Bcell_mem_VB_C003JB51.bed_coverage < quantile(coverage$Bcell_mem_VB_C003JB51.bed_coverage, 0.90),]
##3 Compare range of columns
###Column of first healthy patient
range(coverage$Bcell_mem_VB_C003JB51.bed_coverage)
[1]       0 1552321
range(coverage_cleaned$Bcell_mem_VB_C003JB51.bed_coverage)
[1]     0 38338
###Column of first cancer patient
range(coverage$cancer_VB_S00AYXU1.bed_coverage)
[1]      0 652507
range(coverage_cleaned$cancer_VB_S00AYXU1.bed_coverage)
[1]      0 236806
Example-note: Do not remove the quantiles in this way for more than one column
Tim versucht nochmal was zu Ã¤ndern
ï»¿---
title: "DNA Methylation"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## R Markdown
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
```{r cars}
summary(cars)
```
## Including Plots
You can also embed plots, for example:
```{r pressure, echo=FALSE}
plot(pressure)
```
Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
#Start the project
##Legend
df = data frame
## To make sure which file on my computer offers the environment for my R project:
getwd()
#Read in the data
input_data <- readRDS(file ="CLL-Bcells_list.RDS.gz")
annotation <- read.csv("sample_annotation.csv")
##Divide the data in 3 subgroups
genes <- input_data$genes
promoters <- input_data$promoters
cpgislands <- input_data$cpgislands
# Rename a column
## If you know the number of the columns
names(df)[number_of_col] <- "new_name"
E.g: names(genes)[1] <- "new_name"
##If you have too many columns to know the number
colnames(df)[colnames(df)=="old_name"] <- "new_name"
E.g: colnames(genes)[colnames(genes)=="old_name"] <- "new_name"
#Show if columns have missing values
sum(is.na(df))
--> Number of missing values is shown as result
# Set NAÂ´s to a defined number
df[is.na(df)] <- set_number
E.g.: genes$Symbol[is.na(genes$Symbol)] <- 0
# Set 0 to NA
df[df == 0] <- NA
E.g.: genes$Symbol[genes$Symbol == 0] <- NA
# Create new data frames with selected columns
## Create a data frame with selected columns using indices
dfnew1 <- genes[,c(1,2,3,4,5)]
## Create a data frame with selected columns using indices (easier)
dfnew2 <- genes [, c(1:5)]
## Create a data frame using the names of the columns
dfnew1 <- data.frame(df$subpoint1, df$subpoint2)
E.g.: dfnew1 <- data.frame(genes$Chromosome, genes$CpG)
### Rename all the (old) columns at once ("Chromosome" --> "Chr" ; "CpG" --> "CpGÂ´s")
names(dfnew1) <- c("Chr", "CpG Â´s")
#Visualization
## Histogram (for CpG derivation)
hist(df, main = "Headline", xlab = "Name of x-axis", xlim = c(Starting_Number, Ending_Number), breaks = How_Many_Intervalls)
hist(cpgislands$CpG, main = "Histogram for CpG derivation", xlab = "Number of CpGÂ´s in Region", xlim = c(0,600), breaks = 200)
## Density plot (for CpG derivation)
plot(df), xlab = "X-axis name", main = "",xlim = c(Starting_Number, Ending_Number))
plot(density(genes$CpG), xlab = "Number of CpGÂ´s", main = "",xlim = c(0,2000))
## Boxplots (+modify)
boxplot(df1,df2)
boxplot(df1,df2, xlab = "Example_1", horizontal = T, ylim = c(0,1), ylab = "Non-cancer vs. CLL")
#Clean up our data
## Beta Values
###1 Set all Zero to NAÂ´s (due to possible mistakes)
df[df == 0] <- NA
###2 Go through each row and sum up the NAÂ´s
rmv.rows = apply(df,1, function(x){sum(is.na(x))})
###3 Number of NA`s greater i
which(rmv.rows > i)
### Or even i
which (rmv.rows == i)
###4 Remove your old Dataset with the NAÂ´s with your new Dataset without the NAÂ´s (Remove any row with more than i NAÂ´s)
df = df[-which(rmv.rows > i),]
## Coverage Values
###1 Show me all the Values within the 90% quantile
df[df$specialcolumn < quantile(df$specialcolumn, 0.90),]
###2 Create new dataset with just the values inside 90% quantile
df_new = df[df$specialcolumn < quantile(df$specialcolumn, 0.90),]
# Trying to remove special coverage values (Question at the end)
##1 Create new dataframe only with coverage values (genes)
coverage <- genes[,c(21:30)]
##2 Only keep values within the 90% quantile
coverage_cleaned = coverage[coverage$Bcell_mem_VB_C003JB51.bed_coverage < quantile(coverage$Bcell_mem_VB_C003JB51.bed_coverage, 0.90),]
##3 Compare range of columns
###Column of first healthy patient
range(coverage$Bcell_mem_VB_C003JB51.bed_coverage)
[1]       0 1552321
range(coverage_cleaned$Bcell_mem_VB_C003JB51.bed_coverage)
[1]     0 38338
###Column of first cancer patient
range(coverage$cancer_VB_S00AYXU1.bed_coverage)
[1]      0 652507
range(coverage_cleaned$cancer_VB_S00AYXU1.bed_coverage)
[1]      0 236806
Example-note: Do not remove the quantiles in this way for more than one column
Tim versucht nochmal was zu Ã¤ndern
promoters <- input_data$promoters
cpgislands <- input_data$cpgislands
ï»¿---
#title: "DNA Methylation"
#output: html_document
---
```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
```
## R Markdown
#This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
#When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
```{r cars}
#summary(cars)
```
## Including Plots
#You can also embed plots, for example:
```{r pressure, echo=FALSE}
#plot(pressure)
```
#Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
#Start the project
##Legend
#df = data frame
## To make sure which file on my computer offers the environment for my R project:
#getwd()
#Read in the data
input_data <- readRDS(file ="CLL-Bcells_list.RDS.gz")
annotation <- read.csv("sample_annotation.csv")
##Divide the data in 3 subgroups
genes <- input_data$genes
promoters <- input_data$promoters
cpgislands <- input_data$cpgislands
# Rename a column
## If you know the number of the columns
names(df)[number_of_col] <- "new_name"
E.g: names(genes)[1] <- "new_name"
##If you have too many columns to know the number
colnames(df)[colnames(df)=="old_name"] <- "new_name"
E.g: colnames(genes)[colnames(genes)=="old_name"] <- "new_name"
#Show if columns have missing values
sum(is.na(df))
--> Number of missing values is shown as result
# Set NAÂ´s to a defined number
df[is.na(df)] <- set_number
E.g.: genes$Symbol[is.na(genes$Symbol)] <- 0
# Set 0 to NA
df[df == 0] <- NA
E.g.: genes$Symbol[genes$Symbol == 0] <- NA
# Create new data frames with selected columns
## Create a data frame with selected columns using indices
dfnew1 <- genes[,c(1,2,3,4,5)]
## Create a data frame with selected columns using indices (easier)
dfnew2 <- genes [, c(1:5)]
## Create a data frame using the names of the columns
dfnew1 <- data.frame(df$subpoint1, df$subpoint2)
E.g.: dfnew1 <- data.frame(genes$Chromosome, genes$CpG)
### Rename all the (old) columns at once ("Chromosome" --> "Chr" ; "CpG" --> "CpGÂ´s")
names(dfnew1) <- c("Chr", "CpG Â´s")
#Visualization
## Histogram (for CpG derivation)
hist(df, main = "Headline", xlab = "Name of x-axis", xlim = c(Starting_Number, Ending_Number), breaks = How_Many_Intervalls)
hist(cpgislands$CpG, main = "Histogram for CpG derivation", xlab = "Number of CpGÂ´s in Region", xlim = c(0,600), breaks = 200)
## Density plot (for CpG derivation)
plot(df), xlab = "X-axis name", main = "",xlim = c(Starting_Number, Ending_Number))
plot(density(genes$CpG), xlab = "Number of CpGÂ´s", main = "",xlim = c(0,2000))
## Boxplots (+modify)
boxplot(df1,df2)
boxplot(df1,df2, xlab = "Example_1", horizontal = T, ylim = c(0,1), ylab = "Non-cancer vs. CLL")
#Clean up our data
## Beta Values
###1 Set all Zero to NAÂ´s (due to possible mistakes)
df[df == 0] <- NA
###2 Go through each row and sum up the NAÂ´s
rmv.rows = apply(df,1, function(x){sum(is.na(x))})
###3 Number of NA`s greater i
which(rmv.rows > i)
### Or even i
which (rmv.rows == i)
###4 Remove your old Dataset with the NAÂ´s with your new Dataset without the NAÂ´s (Remove any row with more than i NAÂ´s)
df = df[-which(rmv.rows > i),]
## Coverage Values
###1 Show me all the Values within the 90% quantile
df[df$specialcolumn < quantile(df$specialcolumn, 0.90),]
###2 Create new dataset with just the values inside 90% quantile
df_new = df[df$specialcolumn < quantile(df$specialcolumn, 0.90),]
# Trying to remove special coverage values (Question at the end)
##1 Create new dataframe only with coverage values (genes)
coverage <- genes[,c(21:30)]
##2 Only keep values within the 90% quantile
coverage_cleaned = coverage[coverage$Bcell_mem_VB_C003JB51.bed_coverage < quantile(coverage$Bcell_mem_VB_C003JB51.bed_coverage, 0.90),]
##3 Compare range of columns
###Column of first healthy patient
range(coverage$Bcell_mem_VB_C003JB51.bed_coverage)
[1]       0 1552321
range(coverage_cleaned$Bcell_mem_VB_C003JB51.bed_coverage)
[1]     0 38338
###Column of first cancer patient
range(coverage$cancer_VB_S00AYXU1.bed_coverage)
[1]      0 652507
range(coverage_cleaned$cancer_VB_S00AYXU1.bed_coverage)
[1]      0 236806
Example-note: Do not remove the quantiles in this way for more than one column
Tim versucht nochmal was zu Ã¤ndern
input_data <- readRDS(file ="CLL-Bcells_list.RDS.gz")
annotation <- read.csv("sample_annotation.csv")
##Divide the data in 3 subgroups
genes <- input_data$genes
promoters <- input_data$promoters
cpgislands <- input_data$cpgislands
View(genes)
Coverage <- genes[,c(21:30)]
View(Coverage)
mean(data.matrix((Coverage)))
mean(data.matrix(Coverage))
rowSums?
?rowSums
rowMeans(data.matrix(Coverage))
Mean_Coverage <- rowSums(data.matrix(Coverage))
View(Mean_Coverage)
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", xlim = c(0,50000))
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", xlim = c(0,500000))
range(Mean_Coverage)
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", xlim = c(0,10000000))
dim(Mean_Coverage)
max(Mean_Coverage)
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", xlim = c(0,10000000), log = "x")
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", xlim = c(0,10000000), log = "y")
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", xlim = c(0,10000000), log = "x")
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", xlim = c(0,1000000), log = "x")
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", xlim = c(0,1000000), log = "x")
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", xlim = c(0,1000000), log = "10")
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", xlim = c(0,1000000))
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", log="x")
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", log="y")
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", log="x")
Mean_Coverage [Mean_Coverage == 0] <- 2
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", log="x")
View(Mean_Coverage)
plot(density(Mean_Coverage), main = "Mean_Coverage_Genes", xlim = c(0,1000000))
abline?
?abline
abline?
abline
abline(v = summary(Mean_Coverage)[2:5], col =c("blue", "red", "black", "orange"),
lty = 2))
abline(v = summary(Mean_Coverage), col =c("blue", "red", "black", "orange"),
lty = 2))
abline(v = summary(Mean_Coverage), col =c("blue", "red", "black", "orange"),
lty = 2))
abline(v = summary(Mean_Coverage), col =c("blue", "red", "black", "orange"),
lty = 2)
quantile(Mean_Coverage)
?quantile
quantile(x, probs = seq(90))
quantile(x, probs = seq(90), na.rm = FALSE)
quantile(Mean_Coverage, probs = seq(90), na.rm = FALSE)
quantile(Mean_Coverage, c(0.80, .90, .95))
#This is the code for our project
#Read in the data
input_data <- readRDS(file ="CLL-Bcells_list.RDS.gz")
annotation <- read.csv("sample_annotation.csv")
##Divide the data in 4 subgroups
genes <- input_data$genes
promoters <- input_data$promoters
cpgislands <- input_data$cpgislands
tiling <- input_data$tiling
#Rename our patients in "genes"
names(genes)[11] <- "P1_healthy_beta"
names(genes)[12] <- "P2_healthy_beta"
names(genes)[13] <- "P3_healthy_beta"
names(genes)[14] <- "P4_healthy_beta"
names(genes)[15] <- "P5_healthy_beta"
names(genes)[16] <- "P6_CLL_beta"
names(genes)[17] <- "P7_CLL_beta"
names(genes)[18] <- "P8_CLL_beta"
names(genes)[19] <- "P9_CLL_beta"
names(genes)[20] <- "P10_CLL_beta"
names(genes)[21] <- "P1_healthy_coverage"
names(genes)[22] <- "P2_healthy_coverage"
names(genes)[23] <- "P3_healthy_coverage"
names(genes)[24] <- "P4_healthy_coverage"
names(genes)[25] <- "P5_healthy_coverage"
names(genes)[26] <- "P6_CLL_coverage"
names(genes)[27] <- "P7_CLL_coverage"
names(genes)[28] <- "P8_CLL_coverage"
names(genes)[29] <- "P9_CLL_coverage"
names(genes)[30] <- "P10_CLL_coverage"
#Create a data frame containing coverage values
cov_genes <- genes[ ,c(21:30)]
#Calculate coverage means for each gene
cov_genes_means <- rowMeans(data.matrix(cov_genes))
# logarithmic density plot of coverage values
plot(density(cov_genes_means), xlab = "coverage means", main = "coverage distribution", log = "x"
))
plot(density(cov_genes_means), xlab = "coverage means", main = "coverage distribution", log = "x"
)
#Load sample data
Samples <- readRDS(file = "Mantle-Bcell_list.RDS.gz")
#Loading annotation data file
input_data_csv <-
read.csv(file = "sample_annotation.csv", sep = ",")
View(input_data_csv)
#creating a data frame to understand the different names of the original data frame of genes
Name <-
c(
"Chromosome",
"Start",
"End",
"Strand",
"Symbol",
"entrezID",
"CpG",
"GC",
"G",
"C",
".bed",
".bed_coverage",
"average depth of sequencing coverage",
"beta value",
"Whole genome bisulfite sequencing"
)
Name2 <-
c(
"...",
"Start position (bp)",
"End position (bp",
"...",
"Corresponding gene symbol (only in gene table)",
"Gene ID from entrezGene Database",
"# of CpGs in region",
"Number of GCs in region",
"Number of Gs in region",
"Number of Cs in region",
"methylation BETA value (Percentage of Methylation)",
"sequencing depth at this position aka. the number of reads mapped to this region",
"can be defined theoretically as LN/G, where L is the read length, N is the number of reads and G is the haploid genome length.",
" from 0 (demethylated) to 1 (fully methylated)",
"https://de.wikipedia.org/wiki/Bisulfit-Sequenzierung"
)
table_names <- data.frame(Name = Name, y = Name2)
#copying "genes" data from general list to create a data frame of genes
Gene_data_frame <- Samples$genes
dim(Gene_data_frame)
View(Gene_data_frame)
#some pre-cleaning up: deleting x and y chromosome specific genes
Gene_data_frame_x_y <-
Gene_data_frame[-which(Gene_data_frame$Chromosome == "chrX"), ]
Gene_data_frame_x_y <-
Gene_data_frame_x_y[-which(Gene_data_frame_x_y$Chromosome == "chrY"), ]
#tidy up the data by spliting up the data to different data frame
healthy_coverage <- Gene_data_frame_x_y[, 21:25]
cancer_coverage <- Gene_data_frame_x_y[, 26:30]
healthy_beta_values <- Gene_data_frame_x_y[, 11:15]
cancer_beta_values <- Gene_data_frame_x_y[, 16:20]
####Coverage and Beta-Value problem####
#######################################
#mean and sd value histogram of every gene + quantiles
mean_cancer_coverage <- rowMeans(cancer_coverage)
hist(
log10(mean_cancer_coverage),
breaks = "fd",
main = "Cancer coverage: Mean frequency",
xlab = "Common logarithm of coverages",
col = c("black"),
border = "white"
)
abline(v = log10(quantile(
mean_cancer_coverage,
probs = seq(0, 1, 0.1),
na.rm = TRUE
)),
col = colors(256),
lwd = 2)
